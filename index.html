<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>JS Terraria - Phase 2</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Segoe UI', sans-serif;
            user-select: none;
        }
        canvas { display: block; }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 10px; left: 10px;
            color: white;
            text-shadow: 2px 2px 0 #000;
            pointer-events: none;
        }
        
        /* Inventory Toolbar */
        #toolbar {
            position: absolute;
            bottom: 20px; left: 50%;
            transform: translateX(-50%);
            display: flex; gap: 5px;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px;
            border-radius: 8px;
            pointer-events: auto;
            border: 2px solid #555;
        }
        .slot {
            width: 40px; height: 40px;
            border: 2px solid #444;
            background-color: #222;
            cursor: pointer;
            display: flex; justify-content: center; align-items: center;
            transition: 0.1s;
        }
        .slot.active {
            border-color: #ffd700;
            background-color: #444;
            transform: translateY(-5px);
        }
        .slot canvas {
            width: 32px; height: 32px; /* Scale the texture icon */
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <h1>JS Terraria v2</h1>
        <p>WASD to Move | Left Click: Mine | Right Click: Place</p>
        <p><strong>New:</strong> Press 6 for Torches to light up caves!</p>
    </div>

    <div id="toolbar"></div>
    <canvas id="gameCanvas"></canvas>

<script>
    // --- CONFIGURATION ---
    const TILE_SIZE = 32;
    const CHUNK_WIDTH = 120;
    const CHUNK_HEIGHT = 80;
    const GRAVITY = 0.5;
    const PLAYER_SPEED = 5;
    const JUMP_FORCE = -9;

    // --- IDS ---
    const BLOCKS = {
        AIR: 0,
        DIRT: 1,
        GRASS: 2,
        STONE: 3,
        WOOD: 4,
        LEAVES: 5,
        TORCH: 6,
        BEDROCK: 99
    };

    // --- ASSETS GENERATOR (Procedural Textures) ---
    // We create canvases for textures so we don't need external images
    const TEXTURES = {};
    
    function createTexture(type, color, noiseIntensity) {
        const c = document.createElement('canvas');
        c.width = TILE_SIZE; c.height = TILE_SIZE;
        const ctx = c.getContext('2d');
        
        // Base color
        ctx.fillStyle = color;
        ctx.fillRect(0, 0, TILE_SIZE, TILE_SIZE);
        
        // Add Noise
        for(let i=0; i<40; i++) {
            ctx.fillStyle = Math.random() > 0.5 ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';
            const s = Math.random() * 4 + 2;
            ctx.fillRect(Math.random()*TILE_SIZE, Math.random()*TILE_SIZE, s, s);
        }

        // Specific details
        if(type === 'grass') {
            ctx.fillStyle = '#4caf50';
            ctx.fillRect(0,0,TILE_SIZE, 8); // Green top
            for(let i=0; i<10; i++) {
                ctx.fillRect(Math.random()*28, 6, 4, 4); // Drips
            }
        }
        if(type === 'wood') {
            ctx.fillStyle = 'rgba(0,0,0,0.1)';
            ctx.fillRect(4, 0, 4, 32);
            ctx.fillRect(14, 0, 4, 32);
            ctx.fillRect(24, 0, 4, 32);
        }
        if(type === 'leaves') {
            ctx.fillStyle = '#2e7d32';
            ctx.fillRect(0,0,32,32);
            for(let i=0; i<20; i++) ctx.clearRect(Math.random()*30, Math.random()*30, 4, 4);
        }
        if(type === 'torch') {
            ctx.clearRect(0,0,32,32);
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(14, 10, 4, 10); // stick
            ctx.fillStyle = '#FF4500';
            ctx.fillRect(12, 6, 8, 8); // flame center
            ctx.fillStyle = '#FFD700';
            ctx.fillRect(14, 8, 4, 4); // flame core
        }

        return c;
    }

    // Generate the textures on load
    function initTextures() {
        TEXTURES[BLOCKS.DIRT] = createTexture('dirt', '#5d4037', 0.2);
        TEXTURES[BLOCKS.GRASS] = createTexture('grass', '#5d4037', 0.2);
        TEXTURES[BLOCKS.STONE] = createTexture('stone', '#757575', 0.3);
        TEXTURES[BLOCKS.WOOD] = createTexture('wood', '#795548', 0.1);
        TEXTURES[BLOCKS.LEAVES] = createTexture('leaves', '#2e7d32', 0);
        TEXTURES[BLOCKS.BEDROCK] = createTexture('bedrock', '#222', 0.5);
        TEXTURES[BLOCKS.TORCH] = createTexture('torch', '#fff', 0);
    }

    // --- STATE ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    let world = [];
    let walls = []; // Background walls
    let lightMap = []; // Lighting values (0.0 to 1.0)
    
    let camera = { x: 0, y: 0 };
    let mouse = { x: 0, y: 0 };
    let selectedBlock = BLOCKS.DIRT;
    
    const player = { x: 0, y: 0, width: 20, height: 50, vx: 0, vy: 0, grounded: false };
    const keys = { left: false, right: false, up: false };

    // --- INITIALIZATION ---
    function init() {
        initTextures();
        resize();
        generateWorld();
        createToolbar();
        
        // Player Start
        player.x = (CHUNK_WIDTH * TILE_SIZE) / 2;
        player.y = 10 * TILE_SIZE;
        
        window.addEventListener('resize', resize);
        window.addEventListener('keydown', e => handleKey(e, true));
        window.addEventListener('keyup', e => handleKey(e, false));
        window.addEventListener('mousemove', e => {
            const rect = canvas.getBoundingClientRect();
            mouse.x = e.clientX - rect.left;
            mouse.y = e.clientY - rect.top;
        });
        window.addEventListener('mousedown', handleMouseDown);
        window.addEventListener('contextmenu', e => e.preventDefault());
        
        loop();
    }

    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        ctx.imageSmoothingEnabled = false;
    }

    function createToolbar() {
        const toolbar = document.getElementById('toolbar');
        const items = [BLOCKS.DIRT, BLOCKS.GRASS, BLOCKS.STONE, BLOCKS.WOOD, BLOCKS.LEAVES, BLOCKS.TORCH];
        
        items.forEach((id, i) => {
            const slot = document.createElement('div');
            slot.className = i===0 ? 'slot active' : 'slot';
            slot.onclick = () => {
                document.querySelectorAll('.slot').forEach(s => s.classList.remove('active'));
                slot.classList.add('active');
                selectedBlock = id;
            };
            
            // Append icon
            const icon = document.createElement('canvas');
            icon.width = 32; icon.height = 32;
            const ictx = icon.getContext('2d');
            ictx.drawImage(TEXTURES[id], 0, 0);
            slot.appendChild(icon);
            
            // Keyboard shortcut hint
            const num = document.createElement('span');
            num.style.position = 'absolute';
            num.style.bottom = '2px';
            num.style.right = '2px';
            num.style.fontSize = '10px';
            num.style.color = 'white';
            num.innerText = i + 1;
            slot.appendChild(num);

            toolbar.appendChild(slot);
        });
    }

    // --- WORLD GEN ---
    function generateWorld() {
        world = []; walls = []; lightMap = [];
        const groundLevel = 25;

        for (let x = 0; x < CHUNK_WIDTH; x++) {
            world[x] = []; walls[x] = []; lightMap[x] = [];
            const surfaceY = groundLevel + Math.floor(Math.sin(x/6)*4) + Math.floor(Math.cos(x/20)*6);
            
            for (let y = 0; y < CHUNK_HEIGHT; y++) {
                lightMap[x][y] = 0; // Reset light
                
                // Walls generation (Background)
                if (y > surfaceY + 1) {
                    walls[x][y] = (y > surfaceY + 10) ? BLOCKS.STONE : BLOCKS.DIRT;
                } else {
                    walls[x][y] = BLOCKS.AIR;
                }

                // Blocks generation (Foreground)
                if (y >= CHUNK_HEIGHT - 2) {
                    world[x][y] = BLOCKS.BEDROCK;
                } else if (y >= surfaceY) {
                    if (y === surfaceY) world[x][y] = BLOCKS.GRASS;
                    else if (y > surfaceY + 8 && Math.random() > 0.08) world[x][y] = BLOCKS.STONE;
                    else if (Math.random() > 0.02) world[x][y] = BLOCKS.DIRT;
                    else world[x][y] = BLOCKS.AIR; // Caves
                } else {
                    world[x][y] = BLOCKS.AIR;
                }
            }
            // Trees
            if (x > 5 && x < CHUNK_WIDTH-5 && world[x][surfaceY] === BLOCKS.GRASS && Math.random() < 0.1) {
                const h = 4 + Math.floor(Math.random()*4);
                for(let i=1; i<=h; i++) world[x][surfaceY-i] = BLOCKS.WOOD;
                for(let lx=x-2; lx<=x+2; lx++) {
                    for(let ly=surfaceY-h-2; ly<=surfaceY-h; ly++) {
                        if(Math.abs(lx-x)+Math.abs(ly-(surfaceY-h)) < 4 && world[lx][ly]===BLOCKS.AIR) 
                            world[lx][ly] = BLOCKS.LEAVES;
                    }
                }
            }
        }
    }

    // --- LOGIC ---
    function update() {
        // Physics
        if (keys.right) player.vx += 0.5;
        if (keys.left) player.vx -= 0.5;
        player.vx *= 0.9;
        player.vy = Math.min(player.vy + GRAVITY, 12);
        
        movePlayer(player.vx, 0);
        movePlayer(0, player.vy);

        // Update Camera
        camera.x = player.x - canvas.width/2;
        camera.y = player.y - canvas.height/2;
        camera.x = Math.max(0, Math.min(camera.x, CHUNK_WIDTH*TILE_SIZE - canvas.width));
        camera.y = Math.max(0, Math.min(camera.y, CHUNK_HEIGHT*TILE_SIZE - canvas.height));

        // Update Lighting (Only around player to save CPU)
        updateLighting();
    }

    function movePlayer(vx, vy) {
        player.x += vx;
        player.y += vy;
        
        const startX = Math.floor(player.x / TILE_SIZE);
        const endX = Math.floor((player.x + player.width) / TILE_SIZE);
        const startY = Math.floor(player.y / TILE_SIZE);
        const endY = Math.floor((player.y + player.height) / TILE_SIZE);

        for (let y = startY; y <= endY; y++) {
            for (let x = startX; x <= endX; x++) {
                if (x < 0 || x >= CHUNK_WIDTH || y < 0 || y >= CHUNK_HEIGHT) continue;
                const block = world[x][y];
                if (block !== BLOCKS.AIR && block !== BLOCKS.LEAVES && block !== BLOCKS.TORCH) {
                    if (vx > 0) player.x = x * TILE_SIZE - player.width - 0.1;
                    else if (vx < 0) player.x = (x + 1) * TILE_SIZE + 0.1;
                    else if (vy > 0) { player.y = y * TILE_SIZE - player.height - 0.1; player.grounded = true; player.vy = 0; }
                    else if (vy < 0) { player.y = (y + 1) * TILE_SIZE + 0.1; player.vy = 0; }
                }
            }
        }
    }

    function updateLighting() {
        // Reset visible area light map
        const startX = Math.floor(camera.x / TILE_SIZE) - 5;
        const endX = startX + Math.floor(canvas.width / TILE_SIZE) + 10;
        const startY = Math.floor(camera.y / TILE_SIZE) - 5;
        const endY = startY + Math.floor(canvas.height / TILE_SIZE) + 10;

        // BFS Queue for light propagation
        let queue = [];

        for (let x = Math.max(0, startX); x < Math.min(CHUNK_WIDTH, endX); x++) {
            for (let y = Math.max(0, startY); y < Math.min(CHUNK_HEIGHT, endY); y++) {
                // Sun checks
                if (world[x][y] === BLOCKS.AIR && walls[x][y] === BLOCKS.AIR) {
                    // If it's open sky background, full light
                    lightMap[x][y] = 1.0;
                    queue.push({x, y, intensity: 1.0});
                } else if (world[x][y] === BLOCKS.TORCH) {
                    // Torches emit max light
                    lightMap[x][y] = 1.2; // Slightly brighter than sun
                    queue.push({x, y, intensity: 1.2});
                } else {
                    lightMap[x][y] = 0;
                }
            }
        }

        // Propagate Light
        const dirs = [[0,1], [0,-1], [1,0], [-1,0]];
        let head = 0;
        while(head < queue.length) {
            const {x, y, intensity} = queue[head++];
            if (intensity <= 0) continue;

            const dropoff = 0.1; // How fast light fades
            
            for (let d of dirs) {
                const nx = x + d[0], ny = y + d[1];
                if (nx >= startX && nx < endX && ny >= startY && ny < endY) {
                    
                    // Solid blocks block light more than air
                    let nextIntensity = intensity - dropoff;
                    if (world[nx][ny] !== BLOCKS.AIR && world[nx][ny] !== BLOCKS.TORCH && world[nx][ny] !== BLOCKS.LEAVES) {
                        nextIntensity -= 0.2; // Solid blocks darken fast
                    }
                    
                    if (nextIntensity > lightMap[nx][ny]) {
                        lightMap[nx][ny] = nextIntensity;
                        queue.push({x: nx, y: ny, intensity: nextIntensity});
                    }
                }
            }
        }
    }

    // --- RENDER ---
    function draw() {
        // Sky Gradient
        const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
        grad.addColorStop(0, '#87CEEB');
        grad.addColorStop(1, '#E0F7FA');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.save();
        ctx.translate(-Math.floor(camera.x), -Math.floor(camera.y));

        const startX = Math.floor(camera.x / TILE_SIZE);
        const endX = startX + (canvas.width / TILE_SIZE) + 1;
        const startY = Math.floor(camera.y / TILE_SIZE);
        const endY = startY + (canvas.height / TILE_SIZE) + 1;

        for (let x = startX; x <= endX; x++) {
            for (let y = startY; y <= endY; y++) {
                if (x < 0 || x >= CHUNK_WIDTH || y < 0 || y >= CHUNK_HEIGHT) continue;
                
                const px = x * TILE_SIZE;
                const py = y * TILE_SIZE;
                const block = world[x][y];
                const wall = walls[x][y];
                const light = Math.min(1, Math.max(0.05, lightMap[x][y] || 0));

                // 1. Draw Background Wall (Darkened)
                if (wall !== BLOCKS.AIR && block === BLOCKS.AIR) {
                    if (TEXTURES[wall]) {
                        ctx.drawImage(TEXTURES[wall], px, py);
                        // Darken walls significantly
                        ctx.fillStyle = 'rgba(0,0,0,0.5)'; 
                        ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                    }
                }

                // 2. Draw Foreground Block
                if (block !== BLOCKS.AIR) {
                    if (TEXTURES[block]) {
                        ctx.drawImage(TEXTURES[block], px, py);
                    }
                }

                // 3. Apply Lighting (Draw black overlay with variable alpha)
                // Alpha 0 = Bright, Alpha 1 = Pitch Black
                ctx.fillStyle = `rgba(0,0,0,${1 - light})`;
                ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
            }
        }

        // Draw Player
        ctx.fillStyle = '#FFCC80';
        ctx.fillRect(player.x, player.y, player.width, 10); // Head
        ctx.fillStyle = '#B71C1C';
        ctx.fillRect(player.x, player.y + 10, player.width, 26); // Body
        ctx.fillStyle = '#1A237E';
        ctx.fillRect(player.x, player.y + 36, player.width, 14); // Legs
        
        // Selection Box
        const mx = Math.floor((mouse.x + camera.x) / TILE_SIZE);
        const my = Math.floor((mouse.y + camera.y) / TILE_SIZE);
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 2;
        ctx.strokeRect(mx * TILE_SIZE, my * TILE_SIZE, TILE_SIZE, TILE_SIZE);

        ctx.restore();
    }

    function handleKey(e, state) {
        if (e.code === 'KeyD') keys.right = state;
        if (e.code === 'KeyA') keys.left = state;
        if ((e.code === 'KeyW' || e.code === 'Space') && state && player.grounded) {
            player.vy = JUMP_FORCE;
            player.grounded = false;
        }
        if (state && e.key >= '1' && e.key <= '6') {
            const index = parseInt(e.key) - 1;
            const slots = document.querySelectorAll('.slot');
            if(slots[index]) slots[index].click();
        }
    }

    function handleMouseDown(e) {
        const mx = Math.floor((mouse.x + camera.x) / TILE_SIZE);
        const my = Math.floor((mouse.y + camera.y) / TILE_SIZE);
        
        const dx = (mx * TILE_SIZE + TILE_SIZE/2) - (player.x + player.width/2);
        const dy = (my * TILE_SIZE + TILE_SIZE/2) - (player.y + player.height/2);
        if (dx*dx + dy*dy > 25000) return; // Range check

        if (mx < 0 || mx >= CHUNK_WIDTH || my < 0 || my >= CHUNK_HEIGHT) return;

        if (e.button === 0) { // Mine
            if (world[mx][my] !== BLOCKS.BEDROCK) world[mx][my] = BLOCKS.AIR;
        } else if (e.button === 2) { // Place
            // Collision check for placement
            const pRect = {l: player.x, r: player.x+player.width, t: player.y, b: player.y+player.height};
            const bRect = {l: mx*TILE_SIZE, r: mx*TILE_SIZE+TILE_SIZE, t: my*TILE_SIZE, b: my*TILE_SIZE+TILE_SIZE};
            
            const colliding = !(pRect.r < bRect.l || pRect.l > bRect.r || pRect.b < bRect.t || pRect.t > bRect.b);
            
            // Allow placing Torches (non-solid) inside player, but not solid blocks
            if (!colliding || selectedBlock === BLOCKS.TORCH) {
                if (world[mx][my] === BLOCKS.AIR) world[mx][my] = selectedBlock;
            }
        }
    }

    function loop() {
        update();
        draw();
        requestAnimationFrame(loop);
    }

    init();
</script>
</body>
</html>