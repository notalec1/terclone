<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>JS Terraria - Debug Mode</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #222; /* Dark grey so we can see canvas boundaries */
            font-family: 'Consolas', 'Courier New', monospace;
            user-select: none;
        }
        canvas { display: block; }

        /* UI Layer */
        #ui-layer {
            position: absolute;
            top: 10px; left: 10px;
            color: white;
            pointer-events: none;
            text-shadow: 1px 1px 0 #000;
        }

        /* Debug Box */
        #debug-stats {
            position: absolute;
            top: 10px; right: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: #0f0;
            padding: 10px;
            border: 1px solid #0f0;
            font-size: 12px;
            display: none; /* Hidden by default */
        }

        /* Toolbar */
        #toolbar {
            position: absolute;
            bottom: 20px; left: 50%;
            transform: translateX(-50%);
            display: flex; gap: 5px;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px;
            border-radius: 8px;
            pointer-events: auto;
            border: 2px solid #555;
        }
        .slot {
            width: 40px; height: 40px;
            border: 2px solid #444;
            background-color: #222;
            cursor: pointer;
            display: flex; justify-content: center; align-items: center;
            position: relative;
        }
        .slot.active {
            border-color: #ffd700;
            background-color: #444;
            transform: translateY(-5px);
        }
        .slot canvas { width: 32px; height: 32px; }
        .slot-num { position: absolute; bottom: 2px; right: 2px; font-size: 10px; color: #aaa; }
    </style>
</head>
<body>

    <div id="ui-layer">
        <h1>Terraria v4 (Debug)</h1>
        <p><strong>L</strong>: Toggle Lighting (Try this if screen is black)</p>
        <p><strong>0</strong>: Toggle Debug Info</p>
        <p>WASD to Move | Left/Right Click to Mine/Place</p>
    </div>

    <div id="debug-stats">
        <div><strong>DEBUG MODE</strong></div>
        <div id="db-fps">FPS: 0</div>
        <div id="db-pos">Pos: 0, 0</div>
        <div id="db-mouse">Mouse: 0, 0</div>
        <div id="db-block">Block: -</div>
        <div id="db-light">Light: -</div>
    </div>

    <div id="toolbar"></div>
    <canvas id="gameCanvas"></canvas>

<script>
    // --- SETTINGS ---
    const TILE_SIZE = 32;
    const CHUNK_WIDTH = 120;
    const CHUNK_HEIGHT = 80;
    const GRAVITY = 0.5;
    
    // --- TOGGLES ---
    let enableLighting = true; // Press L to toggle
    let showDebug = false;     // Press 0 to toggle

    // --- BLOCKS ---
    const BLOCKS = { AIR: 0, DIRT: 1, GRASS: 2, STONE: 3, WOOD: 4, LEAVES: 5, TORCH: 6, BEDROCK: 99 };

    // --- ASSETS ---
    const TEXTURES = {};
    function createTexture(type, color) {
        const c = document.createElement('canvas');
        c.width = TILE_SIZE; c.height = TILE_SIZE;
        const ctx = c.getContext('2d');
        ctx.fillStyle = color; ctx.fillRect(0, 0, TILE_SIZE, TILE_SIZE);
        // Simple noise
        for(let i=0; i<20; i++) {
            ctx.fillStyle = Math.random()>0.5 ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';
            ctx.fillRect(Math.random()*32, Math.random()*32, 4, 4);
        }
        if(type==='grass'){ ctx.fillStyle='#4caf50'; ctx.fillRect(0,0,32,6); }
        if(type==='torch'){ 
            ctx.clearRect(0,0,32,32); 
            ctx.fillStyle='#8B4513'; ctx.fillRect(14,10,4,10);
            ctx.fillStyle='#FFD700'; ctx.fillRect(13,6,6,6);
        }
        return c;
    }
    function initTextures() {
        TEXTURES[BLOCKS.DIRT] = createTexture('dirt', '#5d4037');
        TEXTURES[BLOCKS.GRASS] = createTexture('grass', '#5d4037');
        TEXTURES[BLOCKS.STONE] = createTexture('stone', '#757575');
        TEXTURES[BLOCKS.WOOD] = createTexture('wood', '#795548');
        TEXTURES[BLOCKS.LEAVES] = createTexture('leaves', '#2e7d32');
        TEXTURES[BLOCKS.BEDROCK] = createTexture('bedrock', '#222');
        TEXTURES[BLOCKS.TORCH] = createTexture('torch', '#fff');
    }

    // --- STATE ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    let world = [], walls = [], lightMap = [];
    let camera = { x: 0, y: 0 };
    let mouse = { x: 0, y: 0 };
    let selectedBlock = BLOCKS.DIRT;
    const player = { x: 0, y: 0, w: 20, h: 48, vx: 0, vy: 0, grounded: false };
    const keys = { l: false, r: false, u: false };

    // --- INIT ---
    function init() {
        initTextures();
        resize();
        generateWorld();
        createToolbar();
        
        // Safety: Place player 10 blocks above the generated ground
        const midX = Math.floor(CHUNK_WIDTH / 2);
        // Find ground
        let groundY = 0;
        for(let y=0; y<CHUNK_HEIGHT; y++) {
            if(world[midX][y] !== BLOCKS.AIR) {
                groundY = y;
                break;
            }
        }
        player.x = midX * TILE_SIZE;
        player.y = (groundY - 5) * TILE_SIZE; // 5 blocks above ground

        window.addEventListener('resize', resize);
        window.addEventListener('keydown', onKeyDown);
        window.addEventListener('keyup', onKeyUp);
        window.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });
        window.addEventListener('mousedown', onMouseDown);
        window.addEventListener('contextmenu', e => e.preventDefault());

        updateLighting(true);
        loop();
    }

    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        ctx.imageSmoothingEnabled = false;
    }

    function generateWorld() {
        const surfaceBase = 30;
        for (let x = 0; x < CHUNK_WIDTH; x++) {
            world[x] = []; walls[x] = []; lightMap[x] = [];
            const surfaceY = surfaceBase + Math.floor(Math.sin(x/8)*5);

            for (let y = 0; y < CHUNK_HEIGHT; y++) {
                lightMap[x][y] = 1.0; // Default to bright to prevent black screen on load
                
                // Walls
                walls[x][y] = (y > surfaceY + 2) ? BLOCKS.DIRT : BLOCKS.AIR;
                
                // Blocks
                if (y >= CHUNK_HEIGHT - 2) world[x][y] = BLOCKS.BEDROCK;
                else if (y >= surfaceY) {
                    if (y === surfaceY) world[x][y] = BLOCKS.GRASS;
                    else if (y > surfaceY + 10) world[x][y] = BLOCKS.STONE;
                    else world[x][y] = BLOCKS.DIRT;
                } else {
                    world[x][y] = BLOCKS.AIR;
                }
            }
        }
    }

    // --- GAME LOOP ---
    let lastTime = 0;
    function loop(time) {
        const dt = time - lastTime;
        lastTime = time;

        update();
        draw();
        
        if(showDebug) updateDebugInfo(dt);
        requestAnimationFrame(loop);
    }

    function update() {
        if (keys.r) player.vx += 0.5;
        if (keys.l) player.vx -= 0.5;
        player.vx *= 0.9;
        player.vy = Math.min(player.vy + GRAVITY, 12);

        movePlayer(player.vx, 0);
        movePlayer(0, player.vy);

        // Camera Follow
        camera.x = player.x - canvas.width/2;
        camera.y = player.y - canvas.height/2;
        camera.x = Math.max(0, Math.min(camera.x, CHUNK_WIDTH*TILE_SIZE - canvas.width));
        camera.y = Math.max(0, Math.min(camera.y, CHUNK_HEIGHT*TILE_SIZE - canvas.height));
        
        if(enableLighting) updateLighting(false);
    }

    function movePlayer(vx, vy) {
        player.x += vx; player.y += vy;
        const sx = Math.floor(player.x/TILE_SIZE), ex = Math.floor((player.x+player.w)/TILE_SIZE);
        const sy = Math.floor(player.y/TILE_SIZE), ey = Math.floor((player.y+player.h)/TILE_SIZE);

        for(let y=sy; y<=ey; y++) {
            for(let x=sx; x<=ex; x++) {
                if(x>=0 && x<CHUNK_WIDTH && y>=0 && y<CHUNK_HEIGHT) {
                    const b = world[x][y];
                    if(b !== BLOCKS.AIR && b !== BLOCKS.TORCH && b !== BLOCKS.LEAVES) {
                        if(vx>0) player.x = x*TILE_SIZE - player.w - 0.1;
                        else if(vx<0) player.x = (x+1)*TILE_SIZE + 0.1;
                        else if(vy>0) { player.y = y*TILE_SIZE - player.h - 0.1; player.grounded=true; player.vy=0; }
                        else if(vy<0) { player.y = (y+1)*TILE_SIZE + 0.1; player.vy=0; }
                    }
                }
            }
        }
    }

    // --- LIGHTING ---
    function updateLighting(force) {
        // Bounds
        let sx = force ? 0 : Math.floor(camera.x/TILE_SIZE)-5;
        let ex = force ? CHUNK_WIDTH : sx + Math.floor(canvas.width/TILE_SIZE)+10;
        let sy = force ? 0 : Math.floor(camera.y/TILE_SIZE)-5;
        let ey = force ? CHUNK_HEIGHT : sy + Math.floor(canvas.height/TILE_SIZE)+10;

        sx = Math.max(0, sx); ex = Math.min(CHUNK_WIDTH, ex);
        sy = Math.max(0, sy); ey = Math.min(CHUNK_HEIGHT, ey);

        let queue = [];

        for(let x=sx; x<ex; x++) {
            for(let y=sy; y<ey; y++) {
                lightMap[x][y] = 0; // Reset
                // Sources
                if(walls[x][y] === BLOCKS.AIR) { lightMap[x][y] = 1.0; queue.push({x,y,l:1}); }
                else if(world[x][y] === BLOCKS.TORCH) { lightMap[x][y] = 1.2; queue.push({x,y,l:1.2}); }
            }
        }

        let head = 0;
        const dirs = [[0,1],[0,-1],[1,0],[-1,0]];
        while(head < queue.length) {
            const {x, y, l} = queue[head++];
            if(l <= 0) continue;
            
            for(let d of dirs) {
                const nx=x+d[0], ny=y+d[1];
                if(nx>=sx && nx<ex && ny>=sy && ny<ey) {
                    let nl = l - 0.1; // decay
                    if(world[nx][ny] !== BLOCKS.AIR && world[nx][ny] !== BLOCKS.TORCH) nl -= 0.3; // block decay
                    
                    if(nl > lightMap[nx][ny]) {
                        lightMap[nx][ny] = nl;
                        queue.push({x:nx, y:ny, l:nl});
                    }
                }
            }
        }
    }

    // --- DRAW ---
    function draw() {
        // Sky
        ctx.fillStyle = '#87CEEB';
        ctx.fillRect(0,0,canvas.width, canvas.height);

        ctx.save();
        ctx.translate(-Math.floor(camera.x), -Math.floor(camera.y));

        const sx = Math.floor(camera.x/TILE_SIZE);
        const ex = sx + (canvas.width/TILE_SIZE) + 1;
        const sy = Math.floor(camera.y/TILE_SIZE);
        const ey = sy + (canvas.height/TILE_SIZE) + 1;

        for(let x=sx; x<=ex; x++) {
            for(let y=sy; y<=ey; y++) {
                if(x<0||x>=CHUNK_WIDTH||y<0||y>=CHUNK_HEIGHT) continue;

                const px = x*TILE_SIZE, py = y*TILE_SIZE;
                const b = world[x][y];
                const w = walls[x][y];
                
                // Draw Wall
                if(w !== BLOCKS.AIR && b === BLOCKS.AIR) {
                    if(TEXTURES[w]) {
                        ctx.drawImage(TEXTURES[w], px, py);
                        ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(px,py,TILE_SIZE,TILE_SIZE);
                    }
                }

                // Draw Block
                if(b !== BLOCKS.AIR) {
                    if(TEXTURES[b]) ctx.drawImage(TEXTURES[b], px, py);
                }
                
                // Lighting Overlay
                if(enableLighting) {
                    let l = lightMap[x][y] || 0;
                    l = Math.max(0.05, Math.min(1.0, l));
                    ctx.fillStyle = `rgba(0,0,0,${1-l})`;
                    ctx.fillRect(px,py,TILE_SIZE,TILE_SIZE);
                }

                // DEBUG: Show Grid
                if(showDebug) {
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(px,py,TILE_SIZE,TILE_SIZE);
                }
            }
        }

        // Player
        ctx.fillStyle = '#FFCC80'; ctx.fillRect(player.x, player.y, player.w, 10);
        ctx.fillStyle = '#F44336'; ctx.fillRect(player.x, player.y+10, player.w, 24);
        ctx.fillStyle = '#1E88E5'; ctx.fillRect(player.x, player.y+34, player.w, 14);

        // Selection
        const mx = Math.floor((mouse.x+camera.x)/TILE_SIZE);
        const my = Math.floor((mouse.y+camera.y)/TILE_SIZE);
        ctx.strokeStyle = 'white'; ctx.lineWidth = 2;
        ctx.strokeRect(mx*TILE_SIZE, my*TILE_SIZE, TILE_SIZE, TILE_SIZE);

        ctx.restore();
    }

    // --- DEBUG INFO ---
    function updateDebugInfo(dt) {
        const mx = Math.floor((mouse.x+camera.x)/TILE_SIZE);
        const my = Math.floor((mouse.y+camera.y)/TILE_SIZE);
        
        let blockVal = 'Void', lightVal = 'Void';
        if(mx>=0 && mx<CHUNK_WIDTH && my>=0 && my<CHUNK_HEIGHT) {
            blockVal = world[mx][my];
            lightVal = lightMap[mx][my] ? lightMap[mx][my].toFixed(2) : '0.00';
        }

        document.getElementById('db-fps').innerText = `FPS: ${Math.round(1000/dt)}`;
        document.getElementById('db-pos').innerText = `Player: ${Math.round(player.x)}, ${Math.round(player.y)}`;
        document.getElementById('db-mouse').innerText = `Tile: ${mx}, ${my}`;
        document.getElementById('db-block').innerText = `Block ID: ${blockVal}`;
        document.getElementById('db-light').innerText = `Light: ${lightVal}`;
    }

    // --- INPUT ---
    function onKeyDown(e) {
        if(e.code==='KeyD') keys.r=true;
        if(e.code==='KeyA') keys.l=true;
        if((e.code==='KeyW'||e.code==='Space') && player.grounded) { player.vy = -9; player.grounded=false; }
        if(e.key==='0') { showDebug = !showDebug; document.getElementById('debug-stats').style.display = showDebug ? 'block' : 'none'; }
        if(e.code==='KeyL') enableLighting = !enableLighting;
        if(e.key>='1' && e.key<='6') {
             const i = parseInt(e.key)-1; 
             const s = document.querySelectorAll('.slot'); 
             if(s[i]) s[i].click(); 
        }
    }
    function onKeyUp(e) {
        if(e.code==='KeyD') keys.r=false;
        if(e.code==='KeyA') keys.l=false;
    }
    function onMouseDown(e) {
        const mx = Math.floor((mouse.x+camera.x)/TILE_SIZE);
        const my = Math.floor((mouse.y+camera.y)/TILE_SIZE);
        if(mx<0 || mx>=CHUNK_WIDTH || my<0 || my>=CHUNK_HEIGHT) return;
        
        const dx = (mx*32+16)-(player.x+10), dy = (my*32+16)-(player.y+24);
        if(dx*dx+dy*dy > 25000) return;

        if(e.button===0) { if(world[mx][my]!==99) world[mx][my]=0; }
        if(e.button===2) {
            // Place logic
            const pr={l:player.x,r:player.x+player.w,t:player.y,b:player.y+player.h};
            const br={l:mx*32,r:mx*32+32,t:my*32,b:my*32+32};
            if(selectedBlock===BLOCKS.TORCH || !(pr.r>br.l && pr.l<br.r && pr.b>br.t && pr.t<br.b)) {
                if(world[mx][my]===0) world[mx][my]=selectedBlock;
            }
        }
    }
    function createToolbar() {
        const tb = document.getElementById('toolbar');
        [1,2,3,4,5,6].forEach((id, i) => {
            const s = document.createElement('div'); s.className=i===0?'slot active':'slot';
            s.onclick=()=>{document.querySelectorAll('.slot').forEach(x=>x.classList.remove('active'));s.classList.add('active');selectedBlock=id;};
            const c = document.createElement('canvas'); c.getContext('2d').drawImage(TEXTURES[id],0,0);
            s.appendChild(c); tb.appendChild(s);
        });
    }

    init();
</script>
</body>
</html>