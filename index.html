<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>JS Terraria Clone</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none; /* Prevent text selection while playing */
        }

        canvas {
            display: block;
        }

        #ui-layer {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            text-shadow: 2px 2px 0 #000;
            pointer-events: none;
        }

        #toolbar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 5px;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px;
            border-radius: 8px;
            pointer-events: auto;
        }

        .slot {
            width: 40px;
            height: 40px;
            border: 2px solid #555;
            background-color: #333;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 10px;
            color: white;
            transition: transform 0.1s;
        }

        .slot.active {
            border-color: #ffd700;
            transform: scale(1.1);
            z-index: 10;
        }

        .slot-color {
            width: 20px;
            height: 20px;
            border: 1px solid rgba(0,0,0,0.5);
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <h1>JS Terraria</h1>
        <p>WASD / Arrows to Move & Jump</p>
        <p>Left Click: Mine | Right Click (or Shift+Click): Place</p>
        <p>1-5: Select Block</p>
    </div>

    <div id="toolbar">
        <!-- Javascript will populate this -->
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
    // --- CONFIGURATION ---
    const TILE_SIZE = 32;
    const CHUNK_WIDTH = 100; // Total world width in blocks
    const CHUNK_HEIGHT = 60; // Total world height in blocks
    const GRAVITY = 0.5;
    const TERMINAL_VELOCITY = 12;
    const PLAYER_SPEED = 5;
    const JUMP_FORCE = -9;

    // --- BLOCK DEFINITIONS ---
    const BLOCKS = {
        AIR: 0,
        DIRT: 1,
        GRASS: 2,
        STONE: 3,
        WOOD: 4,
        LEAVES: 5,
        BEDROCK: 99
    };

    const BLOCK_COLORS = {
        [BLOCKS.DIRT]: '#5d4037',
        [BLOCKS.GRASS]: '#388e3c', // We will draw a top layer for grass later
        [BLOCKS.STONE]: '#757575',
        [BLOCKS.WOOD]: '#795548',
        [BLOCKS.LEAVES]: '#2e7d32',
        [BLOCKS.BEDROCK]: '#212121'
    };

    // --- STATE ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    let world = [];
    let camera = { x: 0, y: 0 };
    let mouse = { x: 0, y: 0, worldX: 0, worldY: 0 };
    let selectedBlock = BLOCKS.DIRT;
    
    // Player Object
    const player = {
        x: 0,
        y: 0,
        width: 20,
        height: 56, // almost 2 blocks high
        vx: 0,
        vy: 0,
        grounded: false
    };

    // Input state
    const keys = {
        left: false,
        right: false,
        up: false,
        down: false
    };

    // --- INITIALIZATION ---
    function init() {
        resize();
        generateWorld();
        createToolbar();
        
        // Place player in the middle, above ground
        player.x = (CHUNK_WIDTH * TILE_SIZE) / 2;
        player.y = 10 * TILE_SIZE; // Start high up
        
        window.addEventListener('resize', resize);
        window.addEventListener('keydown', handleKeyDown);
        window.addEventListener('keyup', handleKeyUp);
        window.addEventListener('mousemove', handleMouseMove);
        window.addEventListener('mousedown', handleMouseDown);
        window.addEventListener('contextmenu', e => e.preventDefault()); // Stop right click menu
        
        loop();
    }

    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        ctx.imageSmoothingEnabled = false; // Pixel art look
    }

    function createToolbar() {
        const toolbar = document.getElementById('toolbar');
        const inventory = [BLOCKS.DIRT, BLOCKS.GRASS, BLOCKS.STONE, BLOCKS.WOOD, BLOCKS.LEAVES];
        
        inventory.forEach((blockId, index) => {
            const slot = document.createElement('div');
            slot.className = index === 0 ? 'slot active' : 'slot';
            slot.dataset.id = blockId;
            slot.dataset.index = index;
            slot.onclick = () => selectSlot(index);
            
            // Visual representation
            const colorBox = document.createElement('div');
            colorBox.className = 'slot-color';
            colorBox.style.backgroundColor = BLOCK_COLORS[blockId];
            slot.appendChild(colorBox);
            
            toolbar.appendChild(slot);
        });
    }

    function selectSlot(index) {
        const slots = document.querySelectorAll('.slot');
        slots.forEach(s => s.classList.remove('active'));
        slots[index].classList.add('active');
        selectedBlock = parseInt(slots[index].dataset.id);
    }

    // --- WORLD GENERATION ---
    function generateWorld() {
        // Initialize empty world
        for (let x = 0; x < CHUNK_WIDTH; x++) {
            world[x] = new Array(CHUNK_HEIGHT).fill(BLOCKS.AIR);
        }

        // Simple terrain generation
        const groundLevel = 20; // Blocks from top
        
        for (let x = 0; x < CHUNK_WIDTH; x++) {
            // Add some noise to height
            let heightVariation = Math.floor(Math.sin(x / 5) * 3) + Math.floor(Math.cos(x / 15) * 5);
            let surfaceY = groundLevel + heightVariation;

            for (let y = 0; y < CHUNK_HEIGHT; y++) {
                if (y >= CHUNK_HEIGHT - 2) {
                    world[x][y] = BLOCKS.BEDROCK;
                } else if (y >= surfaceY) {
                    // Logic for block types based on depth
                    if (y === surfaceY) {
                        world[x][y] = BLOCKS.GRASS;
                    } else if (y > surfaceY + 5) {
                        // Random chance for caves (very simple)
                        if (Math.random() > 0.05) {
                            world[x][y] = BLOCKS.STONE;
                        } else {
                            world[x][y] = BLOCKS.AIR; // Cave
                        }
                    } else {
                        world[x][y] = BLOCKS.DIRT;
                    }
                }
            }
            
            // Simple Tree Generator
            if (x > 5 && x < CHUNK_WIDTH - 5 && Math.random() < 0.05 && world[x][surfaceY] === BLOCKS.GRASS) {
                spawnTree(x, surfaceY - 1);
            }
        }
    }

    function spawnTree(x, y) {
        const height = 4 + Math.floor(Math.random() * 3);
        // Trunk
        for (let i = 0; i < height; i++) {
            if (y - i >= 0) world[x][y - i] = BLOCKS.WOOD;
        }
        // Leaves
        for (let lx = x - 2; lx <= x + 2; lx++) {
            for (let ly = y - height - 2; ly <= y - height; ly++) {
                if (lx >= 0 && lx < CHUNK_WIDTH && ly >= 0 && Math.abs(lx-x) + Math.abs(ly-(y-height)) < 4) {
                    if (world[lx][ly] === BLOCKS.AIR) world[lx][ly] = BLOCKS.LEAVES;
                }
            }
        }
    }

    // --- GAME LOOP & LOGIC ---
    function loop() {
        update();
        draw();
        requestAnimationFrame(loop);
    }

    function update() {
        // 1. Horizontal Movement
        if (keys.right) player.vx += 0.5;
        if (keys.left) player.vx -= 0.5;
        
        // Friction
        player.vx *= 0.9;
        
        // 2. Vertical Movement (Gravity)
        player.vy += GRAVITY;
        if (player.vy > TERMINAL_VELOCITY) player.vy = TERMINAL_VELOCITY;

        // 3. Move X and resolve collision
        player.x += player.vx;
        checkCollision('x');

        // 4. Move Y and resolve collision
        player.y += player.vy;
        checkCollision('y');

        // 5. Keep player in world bounds
        if (player.x < 0) player.x = 0;
        if (player.x > CHUNK_WIDTH * TILE_SIZE - player.width) player.x = CHUNK_WIDTH * TILE_SIZE - player.width;

        // 6. Camera Follow
        // Center the camera on the player
        camera.x = player.x - canvas.width / 2;
        camera.y = player.y - canvas.height / 2;

        // Clamp camera to world bounds
        if (camera.x < 0) camera.x = 0;
        if (camera.y < 0) camera.y = 0;
        if (camera.x > CHUNK_WIDTH * TILE_SIZE - canvas.width) camera.x = CHUNK_WIDTH * TILE_SIZE - canvas.width;
        if (camera.y > CHUNK_HEIGHT * TILE_SIZE - canvas.height) camera.y = CHUNK_HEIGHT * TILE_SIZE - canvas.height;
    }

    function checkCollision(axis) {
        // Calculate the tile indices the player overlaps
        const startX = Math.floor(player.x / TILE_SIZE);
        const endX = Math.floor((player.x + player.width) / TILE_SIZE);
        const startY = Math.floor(player.y / TILE_SIZE);
        const endY = Math.floor((player.y + player.height) / TILE_SIZE);

        for (let y = startY; y <= endY; y++) {
            for (let x = startX; x <= endX; x++) {
                if (x >= 0 && x < CHUNK_WIDTH && y >= 0 && y < CHUNK_HEIGHT) {
                    const block = world[x][y];
                    
                    if (block !== BLOCKS.AIR && block !== BLOCKS.LEAVES) { // Leaves aren't solid in this version
                        if (axis === 'x') {
                            if (player.vx > 0) { // Moving right
                                player.x = x * TILE_SIZE - player.width - 0.01;
                            } else if (player.vx < 0) { // Moving left
                                player.x = (x + 1) * TILE_SIZE + 0.01;
                            }
                            player.vx = 0;
                        } else {
                            if (player.vy > 0) { // Falling
                                player.y = y * TILE_SIZE - player.height - 0.01;
                                player.grounded = true;
                                player.vy = 0;
                            } else if (player.vy < 0) { // Jumping up
                                player.y = (y + 1) * TILE_SIZE + 0.01;
                                player.vy = 0;
                            }
                        }
                    }
                }
            }
        }
    }

    // --- DRAWING ---
    function draw() {
        // Sky background
        ctx.fillStyle = '#87CEEB';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Calculate visible range
        const startCol = Math.floor(camera.x / TILE_SIZE);
        const endCol = startCol + (canvas.width / TILE_SIZE) + 1;
        const startRow = Math.floor(camera.y / TILE_SIZE);
        const endRow = startRow + (canvas.height / TILE_SIZE) + 1;

        // Offset context by camera position
        ctx.save();
        ctx.translate(-camera.x, -camera.y);

        // Draw World
        for (let x = startCol; x <= endCol; x++) {
            for (let y = startRow; y <= endRow; y++) {
                if (x >= 0 && x < CHUNK_WIDTH && y >= 0 && y < CHUNK_HEIGHT) {
                    const blockId = world[x][y];
                    if (blockId !== BLOCKS.AIR) {
                        ctx.fillStyle = BLOCK_COLORS[blockId];
                        ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                        
                        // Grass Topper Details
                        if (blockId === BLOCKS.GRASS) {
                            ctx.fillStyle = '#4caf50';
                            ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, 6);
                        }
                        
                        // Simple Shading (darker borders)
                        ctx.strokeStyle = 'rgba(0,0,0,0.1)';
                        ctx.strokeRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                    }
                }
            }
        }

        // Highlight Mouse Cursor
        const mouseTileX = Math.floor((mouse.x + camera.x) / TILE_SIZE);
        const mouseTileY = Math.floor((mouse.y + camera.y) / TILE_SIZE);
        
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
        ctx.lineWidth = 2;
        ctx.strokeRect(mouseTileX * TILE_SIZE, mouseTileY * TILE_SIZE, TILE_SIZE, TILE_SIZE);

        // Draw Player
        // Head
        ctx.fillStyle = '#FFCC80'; // Skin
        ctx.fillRect(player.x, player.y, player.width, 10);
        // Shirt
        ctx.fillStyle = '#F44336'; // Red shirt
        ctx.fillRect(player.x, player.y + 10, player.width, 26);
        // Pants
        ctx.fillStyle = '#1E88E5'; // Blue pants
        ctx.fillRect(player.x, player.y + 36, player.width, 20);

        ctx.restore();
    }

    // --- INPUT HANDLING ---
    function handleKeyDown(e) {
        if (e.code === 'KeyD' || e.code === 'ArrowRight') keys.right = true;
        if (e.code === 'KeyA' || e.code === 'ArrowLeft') keys.left = true;
        if ((e.code === 'KeyW' || e.code === 'Space' || e.code === 'ArrowUp') && player.grounded) {
            player.vy = JUMP_FORCE;
            player.grounded = false;
        }
        
        // Number keys for inventory
        if (e.key >= '1' && e.key <= '5') {
            selectSlot(parseInt(e.key) - 1);
        }
    }

    function handleKeyUp(e) {
        if (e.code === 'KeyD' || e.code === 'ArrowRight') keys.right = false;
        if (e.code === 'KeyA' || e.code === 'ArrowLeft') keys.left = false;
    }

    function handleMouseMove(e) {
        mouse.x = e.clientX;
        mouse.y = e.clientY;
    }

    function handleMouseDown(e) {
        const mx = Math.floor((mouse.x + camera.x) / TILE_SIZE);
        const my = Math.floor((mouse.y + camera.y) / TILE_SIZE);
        
        // Calculate distance from player
        const playerCenterX = player.x + player.width/2;
        const playerCenterY = player.y + player.height/2;
        const blockCenterX = mx * TILE_SIZE + TILE_SIZE/2;
        const blockCenterY = my * TILE_SIZE + TILE_SIZE/2;
        
        const dist = Math.hypot(playerCenterX - blockCenterX, playerCenterY - blockCenterY);
        
        // Range Check (can only mine/place within 150px)
        if (dist > 150) return;

        if (mx >= 0 && mx < CHUNK_WIDTH && my >= 0 && my < CHUNK_HEIGHT) {
            if (e.button === 0 && !e.shiftKey) { 
                // Left Click: Mine
                if (world[mx][my] !== BLOCKS.BEDROCK) {
                    world[mx][my] = BLOCKS.AIR;
                }
            } else if (e.button === 2 || (e.button === 0 && e.shiftKey)) {
                // Right Click (or Shift+Click): Place
                // Don't place inside player
                const playerRect = {x: player.x, y: player.y, w: player.width, h: player.height};
                const blockRect = {x: mx * TILE_SIZE, y: my * TILE_SIZE, w: TILE_SIZE, h: TILE_SIZE};
                
                // Simple AABB overlap check for placement
                if (!(playerRect.x < blockRect.x + blockRect.w &&
                      playerRect.x + playerRect.w > blockRect.x &&
                      playerRect.y < blockRect.y + blockRect.h &&
                      playerRect.y + playerRect.h > blockRect.y)) {
                     
                     if (world[mx][my] === BLOCKS.AIR) {
                         world[mx][my] = selectedBlock;
                     }
                }
            }
        }
    }

    // Start Game
    init();

</script>
</body>
</html>
