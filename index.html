<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>JS Terraria - v3</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Segoe UI', sans-serif;
            user-select: none;
        }
        canvas { display: block; }

        /* --- UI: HELP BUTTON & CARD --- */
        #info-toggle {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 40px;
            height: 40px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #fff;
            color: #fff;
            border-radius: 50%;
            font-size: 24px;
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            z-index: 100;
            transition: 0.2s;
        }
        #info-toggle:hover {
            background: #444;
            transform: scale(1.1);
        }

        #info-card {
            position: absolute;
            top: 60px;
            left: 10px;
            width: 280px;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #555;
            display: none; /* Hidden by default */
            z-index: 99;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
        }
        #info-card h2 { margin-top: 0; color: #ffd700; font-size: 18px; }
        #info-card p { font-size: 14px; line-height: 1.4; color: #ddd; }
        #info-card kbd {
            background: #333;
            padding: 2px 6px;
            border-radius: 4px;
            border: 1px solid #555;
            font-family: monospace;
            font-weight: bold;
            color: #fff;
        }
        #info-card.visible { display: block; }

        /* --- TOOLBAR --- */
        #toolbar {
            position: absolute;
            bottom: 20px; left: 50%;
            transform: translateX(-50%);
            display: flex; gap: 5px;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px;
            border-radius: 8px;
            pointer-events: auto;
            border: 2px solid #555;
        }
        .slot {
            width: 40px; height: 40px;
            border: 2px solid #444;
            background-color: #222;
            cursor: pointer;
            display: flex; justify-content: center; align-items: center;
            transition: 0.1s;
            position: relative;
        }
        .slot.active {
            border-color: #ffd700;
            background-color: #444;
            transform: translateY(-5px);
        }
        .slot canvas { width: 32px; height: 32px; }
        .slot-num {
            position: absolute; bottom: 2px; right: 2px;
            font-size: 10px; color: #aaa;
        }
    </style>
</head>
<body>

    <!-- Toggle Button -->
    <div id="info-toggle" onclick="toggleInfo()">?</div>

    <!-- Expandable Info Card -->
    <div id="info-card">
        <h2>Controls & Help</h2>
        <p><kbd>W</kbd> <kbd>A</kbd> <kbd>S</kbd> <kbd>D</kbd> to Move & Jump</p>
        <p><kbd>Left Click</kbd> to Mine blocks</p>
        <p><kbd>Right Click</kbd> to Place blocks</p>
        <p><kbd>1</kbd> - <kbd>6</kbd> to Select items</p>
        <hr style="border-color: #444;">
        <p><strong>Tips:</strong></p>
        <p>• Use Torches (<kbd>6</kbd>) to explore caves.</p>
        <p>• Mining removes the foreground block.</p>
        <p>• Darker background walls means you are underground.</p>
    </div>

    <div id="toolbar"></div>
    <canvas id="gameCanvas"></canvas>

<script>
    // --- UI LOGIC ---
    function toggleInfo() {
        document.getElementById('info-card').classList.toggle('visible');
    }

    // --- CONFIGURATION ---
    const TILE_SIZE = 32;
    const CHUNK_WIDTH = 120;
    const CHUNK_HEIGHT = 80;
    const GRAVITY = 0.5;
    const PLAYER_SPEED = 5;
    const JUMP_FORCE = -9;

    // --- BLOCKS ---
    const BLOCKS = {
        AIR: 0,
        DIRT: 1,
        GRASS: 2,
        STONE: 3,
        WOOD: 4,
        LEAVES: 5,
        TORCH: 6,
        BEDROCK: 99
    };

    // --- ASSETS (Procedural Textures) ---
    const TEXTURES = {};
    
    function createTexture(type, color) {
        const c = document.createElement('canvas');
        c.width = TILE_SIZE; c.height = TILE_SIZE;
        const ctx = c.getContext('2d');
        
        ctx.fillStyle = color;
        ctx.fillRect(0, 0, TILE_SIZE, TILE_SIZE);
        
        // Noise
        for(let i=0; i<40; i++) {
            ctx.fillStyle = Math.random() > 0.5 ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';
            const s = Math.random() * 4 + 2;
            ctx.fillRect(Math.random()*TILE_SIZE, Math.random()*TILE_SIZE, s, s);
        }

        if(type === 'grass') {
            ctx.fillStyle = '#4caf50';
            ctx.fillRect(0,0,TILE_SIZE, 8);
            for(let i=0; i<10; i++) ctx.fillRect(Math.random()*28, 6, 4, 4);
        }
        if(type === 'wood') {
            ctx.fillStyle = 'rgba(0,0,0,0.1)';
            ctx.fillRect(4, 0, 4, 32); ctx.fillRect(14, 0, 4, 32); ctx.fillRect(24, 0, 4, 32);
        }
        if(type === 'leaves') {
            ctx.fillStyle = '#2e7d32';
            ctx.fillRect(0,0,32,32);
            for(let i=0; i<20; i++) ctx.clearRect(Math.random()*30, Math.random()*30, 4, 4);
        }
        if(type === 'torch') {
            ctx.clearRect(0,0,32,32);
            ctx.fillStyle = '#8B4513'; ctx.fillRect(14, 10, 4, 10);
            ctx.fillStyle = '#FF4500'; ctx.fillRect(12, 6, 8, 8);
            ctx.fillStyle = '#FFD700'; ctx.fillRect(14, 8, 4, 4);
        }
        return c;
    }

    function initTextures() {
        TEXTURES[BLOCKS.DIRT] = createTexture('dirt', '#5d4037');
        TEXTURES[BLOCKS.GRASS] = createTexture('grass', '#5d4037');
        TEXTURES[BLOCKS.STONE] = createTexture('stone', '#757575');
        TEXTURES[BLOCKS.WOOD] = createTexture('wood', '#795548');
        TEXTURES[BLOCKS.LEAVES] = createTexture('leaves', '#2e7d32');
        TEXTURES[BLOCKS.BEDROCK] = createTexture('bedrock', '#222');
        TEXTURES[BLOCKS.TORCH] = createTexture('torch', '#fff');
    }

    // --- GAME STATE ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    let world = [];
    let walls = []; 
    let lightMap = [];
    
    let camera = { x: 0, y: 0 };
    let mouse = { x: 0, y: 0 };
    let selectedBlock = BLOCKS.DIRT;
    
    const player = { x: 0, y: 0, width: 20, height: 48, vx: 0, vy: 0, grounded: false };
    const keys = { left: false, right: false, up: false };

    // --- INIT ---
    function init() {
        initTextures();
        resize();
        generateWorld();
        createToolbar();
        
        player.x = (CHUNK_WIDTH * TILE_SIZE) / 2;
        player.y = 10 * TILE_SIZE;
        
        window.addEventListener('resize', resize);
        window.addEventListener('keydown', e => handleKey(e, true));
        window.addEventListener('keyup', e => handleKey(e, false));
        window.addEventListener('mousemove', e => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
        });
        window.addEventListener('mousedown', handleMouseDown);
        window.addEventListener('contextmenu', e => e.preventDefault());
        
        // Initial lighting pass
        updateLighting(true);
        loop();
    }

    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        ctx.imageSmoothingEnabled = false;
    }

    function createToolbar() {
        const toolbar = document.getElementById('toolbar');
        const items = [BLOCKS.DIRT, BLOCKS.GRASS, BLOCKS.STONE, BLOCKS.WOOD, BLOCKS.LEAVES, BLOCKS.TORCH];
        
        items.forEach((id, i) => {
            const slot = document.createElement('div');
            slot.className = i===0 ? 'slot active' : 'slot';
            slot.onclick = () => {
                document.querySelectorAll('.slot').forEach(s => s.classList.remove('active'));
                slot.classList.add('active');
                selectedBlock = id;
            };
            
            const icon = document.createElement('canvas');
            icon.width = 32; icon.height = 32;
            icon.getContext('2d').drawImage(TEXTURES[id], 0, 0);
            
            const num = document.createElement('span');
            num.className = 'slot-num';
            num.innerText = i + 1;
            
            slot.appendChild(icon);
            slot.appendChild(num);
            toolbar.appendChild(slot);
        });
    }

    // --- GENERATION ---
    function generateWorld() {
        const groundLevel = 25;
        for (let x = 0; x < CHUNK_WIDTH; x++) {
            world[x] = []; walls[x] = []; lightMap[x] = [];
            const surfaceY = groundLevel + Math.floor(Math.sin(x/6)*4) + Math.floor(Math.cos(x/20)*6);
            
            for (let y = 0; y < CHUNK_HEIGHT; y++) {
                // Initialize Light: 1.0 for sky/air, 0.0 for underground
                lightMap[x][y] = (y < surfaceY) ? 1.0 : 0.0;
                
                // Walls
                walls[x][y] = (y > surfaceY + 1) ? BLOCKS.DIRT : BLOCKS.AIR;
                if (y > surfaceY + 10) walls[x][y] = BLOCKS.STONE;

                // Blocks
                if (y >= CHUNK_HEIGHT - 2) world[x][y] = BLOCKS.BEDROCK;
                else if (y >= surfaceY) {
                    if (y === surfaceY) world[x][y] = BLOCKS.GRASS;
                    else if (y > surfaceY + 8 && Math.random() > 0.08) world[x][y] = BLOCKS.STONE;
                    else if (Math.random() > 0.02) world[x][y] = BLOCKS.DIRT;
                    else world[x][y] = BLOCKS.AIR;
                } else {
                    world[x][y] = BLOCKS.AIR;
                }
            }
            // Simple Trees
            if (x > 5 && x < CHUNK_WIDTH-5 && world[x][surfaceY] === BLOCKS.GRASS && Math.random() < 0.1) {
                const h = 4 + Math.floor(Math.random()*4);
                for(let i=1; i<=h; i++) world[x][surfaceY-i] = BLOCKS.WOOD;
                for(let lx=x-2; lx<=x+2; lx++) {
                    for(let ly=surfaceY-h-2; ly<=surfaceY-h; ly++) {
                         if(Math.abs(lx-x)+Math.abs(ly-(surfaceY-h))<4) world[lx][ly] = BLOCKS.LEAVES;
                    }
                }
            }
        }
    }

    // --- GAME LOOP ---
    function update() {
        // Horizontal
        if (keys.right) player.vx += 0.5;
        if (keys.left) player.vx -= 0.5;
        player.vx *= 0.9;
        
        // Vertical
        player.vy = Math.min(player.vy + GRAVITY, 12);
        
        movePlayer(player.vx, 0);
        movePlayer(0, player.vy);

        // Camera
        camera.x = player.x - canvas.width/2;
        camera.y = player.y - canvas.height/2;
        
        // Clamp Camera
        camera.x = Math.max(0, Math.min(camera.x, CHUNK_WIDTH*TILE_SIZE - canvas.width));
        camera.y = Math.max(0, Math.min(camera.y, CHUNK_HEIGHT*TILE_SIZE - canvas.height));

        updateLighting(false);
    }

    function movePlayer(vx, vy) {
        player.x += vx;
        player.y += vy;
        
        const startX = Math.floor(player.x / TILE_SIZE);
        const endX = Math.floor((player.x + player.width) / TILE_SIZE);
        const startY = Math.floor(player.y / TILE_SIZE);
        const endY = Math.floor((player.y + player.height) / TILE_SIZE);

        for (let y = startY; y <= endY; y++) {
            for (let x = startX; x <= endX; x++) {
                if (x < 0 || x >= CHUNK_WIDTH || y < 0 || y >= CHUNK_HEIGHT) continue;
                const block = world[x][y];
                if (block !== BLOCKS.AIR && block !== BLOCKS.LEAVES && block !== BLOCKS.TORCH) {
                    if (vx > 0) player.x = x * TILE_SIZE - player.width - 0.1;
                    else if (vx < 0) player.x = (x + 1) * TILE_SIZE + 0.1;
                    else if (vy > 0) { player.y = y * TILE_SIZE - player.height - 0.1; player.grounded = true; player.vy = 0; }
                    else if (vy < 0) { player.y = (y + 1) * TILE_SIZE + 0.1; player.vy = 0; }
                }
            }
        }
    }

    // --- LIGHTING SYSTEM (FIXED) ---
    function updateLighting(forceAll) {
        // If forceAll is true (startup), calc whole world. Otherwise only screen.
        let startX = forceAll ? 0 : Math.floor(camera.x / TILE_SIZE) - 5;
        let endX = forceAll ? CHUNK_WIDTH : startX + Math.floor(canvas.width / TILE_SIZE) + 10;
        let startY = forceAll ? 0 : Math.floor(camera.y / TILE_SIZE) - 5;
        let endY = forceAll ? CHUNK_HEIGHT : startY + Math.floor(canvas.height / TILE_SIZE) + 10;
        
        // Bounds checking
        startX = Math.max(0, startX);
        endX = Math.min(CHUNK_WIDTH, endX);
        startY = Math.max(0, startY);
        endY = Math.min(CHUNK_HEIGHT, endY);

        let queue = [];

        // 1. Identify Light Sources
        // We iterate the X range, but for Y we must check higher to catch sunlight
        for (let x = startX; x < endX; x++) {
            // Find Topmost Sunlight Source for this column
            // (In a real game we trace rays, here we cheat: if background is AIR, it's sunny)
            for (let y = startY; y < endY; y++) {
                // Reset light for this frame
                lightMap[x][y] = 0; 

                // Is it open air background? (Sunlight)
                if (walls[x][y] === BLOCKS.AIR) {
                    lightMap[x][y] = 1.0;
                    queue.push({x, y, lvl: 1.0});
                }
                // Is it a Torch?
                else if (world[x][y] === BLOCKS.TORCH) {
                    lightMap[x][y] = 1.2;
                    queue.push({x, y, lvl: 1.2});
                }
            }
        }

        // 2. BFS Flood Fill
        let head = 0;
        const dirs = [[0,1], [0,-1], [1,0], [-1,0]];
        
        while(head < queue.length) {
            const {x, y, lvl} = queue[head++];
            if (lvl <= 0) continue;

            const decay = 0.1; // Light falls off by 0.1 per block

            for (let d of dirs) {
                const nx = x + d[0];
                const ny = y + d[1];
                
                if (nx >= startX && nx < endX && ny >= startY && ny < endY) {
                    let nextLvl = lvl - decay;
                    
                    // Blocks reduce light much faster
                    const block = world[nx][ny];
                    if (block !== BLOCKS.AIR && block !== BLOCKS.TORCH && block !== BLOCKS.LEAVES) {
                        nextLvl -= 0.3; 
                    }

                    if (nextLvl > lightMap[nx][ny]) {
                        lightMap[nx][ny] = nextLvl;
                        queue.push({x: nx, y: ny, lvl: nextLvl});
                    }
                }
            }
        }
    }

    // --- DRAWING ---
    function draw() {
        // Sky
        const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
        grad.addColorStop(0, '#87CEEB');
        grad.addColorStop(1, '#E0F7FA');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.save();
        ctx.translate(-Math.floor(camera.x), -Math.floor(camera.y));

        const startX = Math.floor(camera.x / TILE_SIZE);
        const endX = startX + (canvas.width / TILE_SIZE) + 1;
        const startY = Math.floor(camera.y / TILE_SIZE);
        const endY = startY + (canvas.height / TILE_SIZE) + 1;

        for (let x = startX; x <= endX; x++) {
            for (let y = startY; y <= endY; y++) {
                if (x < 0 || x >= CHUNK_WIDTH || y < 0 || y >= CHUNK_HEIGHT) continue;
                
                const px = x * TILE_SIZE;
                const py = y * TILE_SIZE;
                const block = world[x][y];
                const wall = walls[x][y];
                let light = lightMap[x][y];

                // Draw Background Wall
                if (wall !== BLOCKS.AIR && block === BLOCKS.AIR) {
                    if (TEXTURES[wall]) {
                        ctx.drawImage(TEXTURES[wall], px, py);
                        ctx.fillStyle = 'rgba(0,0,0,0.5)'; // Darken wall
                        ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                    }
                }

                // Draw Block
                if (block !== BLOCKS.AIR) {
                    if (TEXTURES[block]) ctx.drawImage(TEXTURES[block], px, py);
                }

                // Apply Lighting Overlay
                // We clamp the light between 0.05 (dark) and 1.0 (bright)
                light = Math.max(0.05, Math.min(1.0, light));
                const shadowStrength = 1 - light;
                
                if (shadowStrength > 0) {
                    ctx.fillStyle = `rgba(0,0,0,${shadowStrength})`;
                    ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                }
            }
        }

        // Player
        ctx.fillStyle = '#FFCC80'; ctx.fillRect(player.x, player.y, player.width, 10);
        ctx.fillStyle = '#B71C1C'; ctx.fillRect(player.x, player.y + 10, player.width, 24);
        ctx.fillStyle = '#1A237E'; ctx.fillRect(player.x, player.y + 34, player.width, 14);

        // Selection
        const mx = Math.floor((mouse.x + camera.x) / TILE_SIZE);
        const my = Math.floor((mouse.y + camera.y) / TILE_SIZE);
        ctx.strokeStyle = 'white'; ctx.lineWidth = 2;
        ctx.strokeRect(mx * TILE_SIZE, my * TILE_SIZE, TILE_SIZE, TILE_SIZE);

        ctx.restore();
    }

    // --- INPUT ---
    function handleKey(e, state) {
        if (e.code === 'KeyD') keys.right = state;
        if (e.code === 'KeyA') keys.left = state;
        if ((e.code === 'KeyW' || e.code === 'Space') && state && player.grounded) {
            player.vy = JUMP_FORCE;
            player.grounded = false;
        }
        if (state && e.key >= '1' && e.key <= '6') {
            const index = parseInt(e.key) - 1;
            const slots = document.querySelectorAll('.slot');
            if(slots[index]) slots[index].click();
        }
    }

    function handleMouseDown(e) {
        const mx = Math.floor((mouse.x + camera.x) / TILE_SIZE);
        const my = Math.floor((mouse.y + camera.y) / TILE_SIZE);
        
        // Distance check
        const dx = (mx * TILE_SIZE + TILE_SIZE/2) - (player.x + player.width/2);
        const dy = (my * TILE_SIZE + TILE_SIZE/2) - (player.y + player.height/2);
        if (dx*dx + dy*dy > 25000) return;

        if (mx < 0 || mx >= CHUNK_WIDTH || my < 0 || my >= CHUNK_HEIGHT) return;

        if (e.button === 0) { // Mine
            if (world[mx][my] !== BLOCKS.BEDROCK) world[mx][my] = BLOCKS.AIR;
        } else if (e.button === 2) { // Place
            const pRect = {l: player.x, r: player.x+player.width, t: player.y, b: player.y+player.height};
            const bRect = {l: mx*TILE_SIZE, r: mx*TILE_SIZE+TILE_SIZE, t: my*TILE_SIZE, b: my*TILE_SIZE+TILE_SIZE};
            const colliding = !(pRect.r < bRect.l || pRect.l > bRect.r || pRect.b < bRect.t || pRect.t > bRect.b);
            
            if (!colliding || selectedBlock === BLOCKS.TORCH) {
                if (world[mx][my] === BLOCKS.AIR) world[mx][my] = selectedBlock;
            }
        }
    }

    function loop() {
        update();
        draw();
        requestAnimationFrame(loop);
    }

    init();

</script>
</body>
</html>